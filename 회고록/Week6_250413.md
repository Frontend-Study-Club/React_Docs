## 💡 **새롭게 안 것**


<aside>

- 규리 : 키를 왜 쓰는지 알게됨. index로 키를 쓸때 시 수정/삭제 시 문제가 됨. fragment 에 key를 쓸 수 있다는 생각을 하게 됨. 로컬에서 키 생성시 패키지 사용. 스트릭 모드를 사용하면 두번 렌더링되어 순수함수가 아닌 것을 발견할 수 있는데, 이전에 계속 값이 변경되었던 기억이 있어서 비순수함수를 사용했었구나 생각하게 됨.
- 화영 : jsx를 리턴할때 하나의 태그로 묶어 리턴해주는데 <>로 해주다가 키를 부여하기 위해 div로 바꾸면 돔 요소가 추가되므로 스타일을 변경해줘야했다. 그런데 <Fragment>로도 키를 부여할 수 있고 돔추가도 안된다는 걸 알게됨. 키는 랜덤으로 즉석 생성하게되면 리액트에서 기존요소도 새로운 요소로 인식해서 매번 새롭게 컴포넌트를 만들어 내므로 사용하지 않는다. 사이드 이펙트를 없애기 위해 순수함수로 만들어줘야하며 기본은 함수 실행 전 존재하는 변수나 객체를 함수내에서 변경하지 말아야한다.
</aside>

## ❓ **궁금한 것**

<aside>

- 규리 : `crypto.randomUUID` 이거 써도 겹치는것 아닌가?
→ 이론상 겹칠 확률은 있긴하지만 굉장히 적음. 네트워크 주소나 타임스템프나 랜덤 숫자로 조합.
- 화영 : 왜 디비의 사용자 테이블에서 고유한 키인 id가 있는데도 불구하고 uuid를 만들까?
    1. **보안** : 예를 들어 사용자 아이디로 서버 요청을 보낼 경우 아이디가 노출되므로 보안에 취약하므로
    2. **분산 시스템 대응** : 여러 서비스 데이터베이스가 따로 관리될 때 사용자 id는 중복되어 충돌될 수 있으므로
</aside>

## ✅ **적용한 것**

<aside>

- 규리 :
- 화영 :
</aside>

## 💬 한 줄 회고

<aside>

- 규리 : uuid.. 새로 알아갑니다. 컴포넌트 만들때 여러가지를 고려해야 한다는 점을 다시 깨닫습니다..
- 화영 : 스트릭모드가 원래 두번 실행되는거였다니.. 그걸 이제야 안것도 웃김 아니 안웃김. useEffect에서 리액트가 모르게 상태변화 하는 것을 자제하자.. 그리고 다음 작업할 때 <Fragment> 로 키를 넣어봐야겠다!
</aside>

## 💫 다음 주 진도

<aside>

- **트리로서 UI 이해하기(**https://ko.react.dev/learn/understanding-your-ui-as-a-tree**)**
- **이벤트에 응답하기(**https://ko.react.dev/learn/responding-to-events**)**
</aside>
